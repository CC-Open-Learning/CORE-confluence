<!DOCTYPE html>
<html>
    <head>
        <title>CORE Framework : Wall Builder Procedural</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">CORE Framework</a></span>
                            </li>
                                                    <li>
                                <span><a href="CORE-Framework_495616264.html">CORE Framework</a></span>
                            </li>
                                                    <li>
                                <span><a href="Procedural-World-Generation_869138443.html">Procedural World Generation</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            CORE Framework : Wall Builder Procedural
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                            
        
    
        
    
        
        
            Created by <span class='author'> Topher Rouleau</span>, last modified on Sept 15, 2023
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>Document is currently a WIP</p></div></div><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>The project that is developing this tech is parking. I’ve tried to update the document to reflect the Wall Builder in its current state</p></div></div><h2 id="WallBuilderProcedural-Overview">Overview</h2><p>In trying to build out the frame of a house manually, I found that this was a good candidate for automation. The manual process was too fiddly and time consuming, So I set out to build a tool that would be be able to generate an entire section of wall frame by simply defining a volume. From placing the volume and defining the parameters, you can currently:<br/></p><ol start="1"><li><p>Create walls of any length, width, or height, containing all the appropriate boards by changing the size of the volume in editor</p></li><li><p>Create walls at any angle by rotating the volume in editor</p></li><li><p>Generate a top plate and bottom plate of a section of wall</p></li><li><p>Generate all the studs in a wall at a regular interval</p></li><li><p>Define the spacing between the studs that are generated by setting a parameter on a per-wall basis</p></li><li><p>Set the thickness of all the boards that will be generated by setting a parameter on a per-wall basis</p></li><li><p>Create a thicker or thinner top plate (top plates are often doubled up) by setting up a parameter on a per-wall basis</p></li><li><p>Ensure that both ends of the wall segment have a stud, even if it would not fall at the regular interval defined above</p></li><li><p>Cut studs to accommodate rough opens like windows and doors</p></li><li><p>Generate windows and door at any size and/or position that would fit in the wall frame</p></li><li><p>Place a texture on the generated object, randomized from a short list</p></li></ol><h2 id="WallBuilderProcedural-SomeTheory">Some Theory</h2><p>The Frame Builder script uses the locators as reference points to build out poly surfaces. There's some math going on to place the locators, and also to find the thickness of the boards, but before we get into that, lets talk a bit about actually drawing a mesh via script.</p><h3 id="WallBuilderProcedural-PartsofaWall">Parts of a Wall</h3><p>You may be unfamiliar with some of the terminology used to describe a wall frame below you can see a labelled diagram of some of the parts, and a glossary of terms beneath that. Some of these parts may have other names, though I've listed the ones I have used in the code and the rest of this document<br/></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/799637517.png" data-image-src="attachments/775815232/799637517.png" data-height="568" data-width="1049" data-unresolved-comment-count="0" data-linked-resource-id="799637517" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230911-173151.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="48cfe32e-16a3-4a37-a1cc-118a377c67ac" data-media-type="file"></span><p><strong>Joist</strong> - a horizontal length of wood that spans a gap. Generally, these support floors or roofs</p><p><strong>Subfloor</strong> - A layer of material that rests on top of the joists</p><p><strong>Rough Opening</strong> - an opening in the wall that will not be covered. Most commonly theses are portals like windows or doors</p><p><strong>Plate</strong> - a board that runs horizontally along the length of the wall, usually at the top or bottom of the frame</p><p><strong>Top Plate</strong> - a plate at the top of the wall section. This is often doubled up</p><p><strong>Bottom Plate</strong> - a plate at the bottom of the section of wall. This rests on the subfloor</p><p><strong>Header</strong> - a thicker piece of wood that spans the top of a rough opening</p><p><strong>Stud</strong> - any board running vertically up and down the part of wall</p><p><strong>Cripple Stud</strong> - a shorter stud that doesn’t reach all the way up to the top or bottom the section of wall. These are common found above or below rough openings</p><p><strong>King Stud</strong> - Studs on either side of a rough opening. There are often two boards here - the king studs are the <u>outer-most</u> ones</p><p><strong>Jack Stud</strong> - Studs on either side of a rough opening. There are often two boards here - the jack studs are the <u>inner-most</u> ones</p><h3 id="WallBuilderProcedural-Triangles">Triangles</h3><p>All models are made of of vertex points floating in space. these points are connected by lines that form edges, and these edges are grouped to form faces. All game objects are made of triangles, even though we may not perceive them as such while modelling or while viewing the finished model. The reason for this is that a triangle is a mathematical certainty: there is only one way to connect all the points so that they form a  shape, and that shape is a triangle. More complex shapes can become mathematically ambiguous, and we may end up with edges where there should be none, which can cause holes in a model. </p><p>While there is only one way to connect all three points to form, the game engine also cares which face is <em>normal</em>, or faces forward and will interact with lighting information. We can influence the normal of the face by the order that we put address the points, and generally we will want to list them in a clockwise order, as this will ensure that the normal faces out. If we list them anti-clockwise, the face will be drawn facing the opposite direction and it will appear to be invisible, unless you spin the camera around. See <em>Figure 03.</em></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/775585813.png" data-image-src="attachments/775815232/775585813.png" data-height="386" data-width="671" data-unresolved-comment-count="0" data-linked-resource-id="775585813" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230802-163406.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="780c9248-69bd-4a5e-91db-d5f512a802ea" data-media-type="file"></span><p>Note that the order of the three points doesn’t matter outside of if it is clockwise or anti-clockwise. That is to say that (0, 2, 1), (2, 1, 0), and (1, 0, 2) will all have the same result.</p><h4 id="WallBuilderProcedural-ScriptingaTriangle">Scripting a Triangle</h4><p>We can leverage the ProBuilder library to assist with drawing our triangle. The function below should draw you a triangle at world centre when it is called:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">using UnityEngine.ProBuilder;
...
public void CreateTriangle()
{
    ProBuilderMesh pBMesh = ProBuilderMesh.Create(
        new Vector3[] {
            //define the vertices that can be used for this mesh.
            //This is using the worldspace cartesian coordinates, but you can use
            //the position of another object&#39;s transform such as our locators
            new Vector3 (0, 0, 0),
            new Vector3 (0, 1, 0),
            new Vector3 (0, 0, 1)
        },
        new Face[] {
            //Draws the triangular face using the vertices defined in the array
            //of Vector3s above. 
            new Face(new int[] {0, 2, 1} )
    });
    //finalize the mesh and ensure the mesh is rendered
    pBMesh.Refresh();
    pBMesh.ToMesh();
}</pre>
</div></div><p /><h3 id="WallBuilderProcedural-Squares">Squares</h3><p>Now that we know a little about drawing triangles, and facing them in the right direction, we can put two triangles together to make a square, or a quad.  To do this, we only need to add a single vertex to our array:</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/775716898.png" data-image-src="attachments/775815232/775716898.png" data-height="437" data-width="432" data-unresolved-comment-count="0" data-linked-resource-id="775716898" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230802-165317.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="f897173f-e5ff-4df8-a140-6b0b500c9a00" data-media-type="file"></span><h4 id="WallBuilderProcedural-ScriptingaSquare">Scripting a Square</h4><p>Naturally, we can quickly iterate on our code to draw a second triangle. We only need to add two lines: one extra point in our array of Vector3s, and one new face:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">using UnityEngine.ProBuilder;
...
public void CreateSquare()
{
    ProBuilderMesh pBMesh = ProBuilderMesh.Create(
        new Vector3[] {
            //define the vertices that can be used for this mesh.
            //This is using the worldspace cartesian coordinates, but you can use
            //the position of another object&#39;s transform such as our locators
            new Vector3 (0, 0, 0),
            new Vector3 (0, 1, 0),
            new Vector3 (0, 0, 1),
            new Vector3 (0, 1, 1)
        },
        new Face[] {
            //Draws 2 triangular facea using the vertices defined in the array
            //of Vector3s above. Together they form a rectangle.
            new Face(new int[] {0, 2, 1} ),
            new Face(new int[] {2, 3, 1} )
    });
    //finalize the mesh and ensure the mesh is rendered
    pBMesh.Refresh();
    pBMesh.ToMesh();
}</pre>
</div></div><h3 id="WallBuilderProcedural-Nets">Nets</h3><p>Hopefully we remember unfolding the nets of objects in grades school! Remember that you can represent the 2d surface of a 3D shape by unfolding it, as seen in <em>Figure 05.</em></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/776044594.png" data-image-src="attachments/775815232/776044594.png" data-height="238" data-width="204" data-unresolved-comment-count="0" data-linked-resource-id="776044594" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230802-170126.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="1380f267-7262-4e9e-8a7c-df27d065db1c" data-media-type="file"></span><p>We can now apply this to the locators we placed on out Wall Builder object before, and combine that information with creating rectangles. It may help to draw this out youself so that you understand the relationships between each vertex. See <em>Figure 06.</em></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/775847978.png" data-image-src="attachments/775815232/775847978.png" data-height="701" data-width="987" data-unresolved-comment-count="0" data-linked-resource-id="775847978" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230802-171354.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="440da91a-8b2e-4af7-8a91-c96b86fb591e" data-media-type="file"></span><p>Of course, we can expand on our code for the rectangle:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">using UnityEngine.ProBuilder;
...
public void CreateCube()
{
    ProBuilderMesh pBMesh = ProBuilderMesh.Create(
        new Vector3[] {
            //define the vertices that make up the front face of the cube
            new Vector3 (0, 0, 0),
            new Vector3 (0, 1, 0),
            new Vector3 (0, 0, 1),
            new Vector3 (0, 1, 1),
            //define the vertices that make up the back face of the cube
            new Vector3 (1, 0, 0),
            new Vector3 (1, 1, 0),
            new Vector3 (1, 0, 1),
            new Vector3 (1, 1, 1)
        },
        new Face[] {
            new Face[] {
                //draw the front quad
                new Face(new int[] {0, 2, 1} ),
                new Face(new int[] {2, 3, 1} ),
                //draw the bottom quad
                new Face(new int[] {4, 0, 5} ),
                new Face(new int[] {0, 1, 5} ),
                //draw the back quad
                new Face(new int[] {6, 4, 7} ),
                new Face(new int[] {4, 5, 7} ),
                //draw the top quad
                new Face(new int[] {2, 6, 3} ),
                new Face(new int[] {6, 7, 3} ),
                //draw the left quad
                new Face(new int[] {0, 4, 2} ),
                new Face(new int[] {4, 6, 2} ),
                //draw the right quad
                new Face(new int[] {3, 7, 1} ),
                new Face(new int[] {7, 5, 1} )
    });
    //finalize the mesh and ensure the mesh is rendered
    pBMesh.Refresh();
    pBMesh.ToMesh();
}</pre>
</div></div><p>The is the overall basis of how we can draw a rectangular mesh. Note that the values in the code above are hard-codes to create a 1m cube that will appear at world centre.  We can, of course, make something a bit more useful by changing how we define where these locators are. </p><h2 id="WallBuilderProcedural-InApplication">In Application</h2><p>We can make a quick adjustment to our code to use the locators on our cube instead of an absolute position. This will of course, let us draw a cube at the position of a cube, which doesn't seem incredibly helpful. Consider though, that these locators do not <strong>need</strong> to be in a cube arrangement, they just are for our applications. This means that you can draw these points out into space and create irregular shapes fairly easily. </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">using UnityEngine.ProBuilder;
...
[SerializeField]
Transform[] cornerLocators;
...
public void CreateCube()
{
    ProBuilderMesh pBMesh = ProBuilderMesh.Create(
        new Vector3[] {
            //define the vertices that make up the front face of the cube
            cornerLocators[0].position,
            cornerLocators[1].position,
            cornerLocators[2].position,
            cornerLocators[3].position,
            //define the vertices that make up the back face of the cube
            cornerLocators[4].position,
            cornerLocators[5].position,
            cornerLocators[6].position,
            cornerLocators[7].position
        },
        new Face[] {
            new Face[] {
                //draw the front quad
                new Face(new int[] {0, 2, 1} ),
                new Face(new int[] {2, 3, 1} ),
                //draw the bottom quad
                new Face(new int[] {4, 0, 5} ),
                new Face(new int[] {0, 1, 5} ),
                //draw the back quad
                new Face(new int[] {6, 4, 7} ),
                new Face(new int[] {4, 5, 7} ),
                //draw the top quad
                new Face(new int[] {2, 6, 3} ),
                new Face(new int[] {6, 7, 3} ),
                //draw the left quad
                new Face(new int[] {0, 4, 2} ),
                new Face(new int[] {4, 6, 2} ),
                //draw the right quad
                new Face(new int[] {3, 7, 1} ),
                new Face(new int[] {7, 5, 1} )
    });
    //finalize the mesh and ensure the mesh is rendered
    pBMesh.Refresh();
    pBMesh.ToMesh();
}</pre>
</div></div><p>Consider that we can use these locators as reference points, and then do some math to create shapes in the positions we want. The math is relatively simple so long as we’re only building rectangular prisms. For example, we can use the bottom 4 locators to build the bottom plate of the wall frame. Note that we’re only addressing Locators 0, 1, 4, and 5:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">...
ProBuilderMesh pBMesh = ProBuilderMesh.Create(
    new Vector3[] {
        //definate a square in space
        cornerLocators[0].position,
        cornerLocators[1].position,
        cornerLocators[0].position + (cornerLocators[0].up * boardThickness),
        cornerLocators[1].position + (cornerLocators[1].up * boardThickness),
        //define a second square in space
        cornerLocators[4].position,
        cornerLocators[5].position,
        cornerLocators[4].position + (cornerLocators[4].up * boardThickness),
        cornerLocators[5].position + (cornerLocators[5].up * boardThickness)
    }
}
...</pre>
</div></div><p>But also consider that we really only need <em>one</em> point <em>somewhere. </em>The math can get as complex as you need. Placing the studs using a single point to build each stud, along with some more math. </p><h2 id="WallBuilderProcedural-ConfiguringtheVolume">Configuring the Volume</h2><p>If for some reason you don’t have access to the prefab that has already be configured you can set up the Wall Builder volume by doing the following:</p><ol start="1"><li><p><strong>Create a cube</strong> in your Unity scene. Rename this object “Wall Builder”</p></li><li><p><strong>Create 8 empty game objects that are children of the Wall Builder.</strong> Name these “Locator 0” through ”Locator7”. Ensure that these locators have no rotational information whatsoever. </p></li><li><p><strong>Snap the locators to the corners of the cube.</strong> Refer to the diagram in <em>Figure 01, </em>as the order will matter. You can snap the empty locators to the vertices by turning on your Translate tool (Hotkey W) and the holding the V Key. You should see the centre of the Translate Gizmo change from three coloured panels to a cyan square. Now click inside the square and drag the gizmo to a vertex. The object should snap when your cursor is close enough tot a valid target..</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/775684149.png" data-image-src="attachments/775815232/775684149.png" data-height="593" data-width="898" data-unresolved-comment-count="0" data-linked-resource-id="775684149" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230802-154108.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="99d83e4b-5ec1-4ed7-9171-e249feb878cb" data-media-type="file"></span></li><li><p>Ensure you have the Frame Builder script. if you don’t, the version as of Aug 02, 2023 is available <a class="external-link" href="https://stuconestogacon.sharepoint.com/:u:/s/VARLab/EW6JMnhsiLNJibbmaqafs4sB7vfgz7KBevhScZNwpSUTzw?e=ghLn8S" rel="nofollow">here</a>. <strong>Put the Frame Builder script on the Wall Builder object.</strong></p></li><li><p>The Frame Builder script will require a small amount of configuration. First, we will need to <strong>define the three materials</strong> that the script will use to assign a semi-random material. You should be able to socket any material into the Material 1, Material 2 , and Material 3 parameters. See <em>Figure 06.</em></p></li><li><p>The next thing we will need to <strong>configure is the List of Corner Locators</strong>. If this section is not expanded, press the drop down that is highlighted in pink in <em>Figure 06.</em> Once this has been expanded, <strong>add 8 items to the list</strong>. You can add items to the list by clicking the plus button highlighted in orange in <em>Figure 06. </em>Each item should come is as an undefined Transform.</p></li></ol><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/776241175.png" data-image-src="attachments/775815232/776241175.png" data-height="406" data-width="368" data-unresolved-comment-count="0" data-linked-resource-id="776241175" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230802-155622.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="8e4dbd9e-2e26-4544-9cb5-5e4c82761274" data-media-type="file"></span><ol start="7"><li><p> With 8 items added to the <strong>point your locators into the list of Corner Locators</strong>. Locator 0 should be at the 0th position in the list, Locator 1 at the 1st, Locator 2 at the 2nd, and so on. </p></li><li><p>The Board thickness, Top Plate Thickness, Stud Distance, and Portal Height parameters can be changed, though the defaults should help to generate these wall segments to the Ontario building code. All of these parameters are in meters, with the exception of Top Plate Thickness, which multiplies the thickness of the top plate by the value. </p></li><li><p>Section Length, Remainder, and the Stud Markers list can be ignored as they were used for debugging. </p></li></ol><p>With these settings configured, you should now be able to press the Play button in Engine and the cube should quickly be replaced with studs. Try duplicating the Wall Builder and translating, rotating, and scaling the volume on various axis to ensure that the script has been configured properly</p><h3 id="WallBuilderProcedural-Notes:">Notes:</h3><p>If you have undesired results, the most likely culprit is that the locators are not at the correct locations, or that the locators were not populated into the list in the proper order. </p><p>I also suggest giving the Wall Builder cube itself a bright single colour material so that it stands out in the scene. </p><p>You materials likely will not look correct. I have leveraged an (incomplete) tri-planar projection shader to ensure that there is no need to UV unwrap the objects that are generated by script. Hopefully this shader eventually becomes part of CoreV2.</p><h2 id="WallBuilderProcedural-CurrentFeatures">Current Features</h2><p>The Wall Builder scripts as of 2023-09-11 include the following scripts:</p><p>FrameBuilder.cs<br/>PortalBuilder.cs<br/>WindowPuncher.cs</p><h3 id="WallBuilderProcedural-FrameBuilder">Frame Builder</h3><p>The Frame Builder script is placed on the green volumes that represent sections of walls. This green volume has 8 markers on in, one on each corner. These 8 marks stay on the corners, even when translating, scaling or rotating the volume. It is these 8 markers that are used as reference in order to build out the section of framed wall along with some of the configurable parameters.</p><p>The Frame Builder has the following parameters and behaviours:</p><p><strong>3 Materials</strong> - Each time a piece of frame is generated, the system picks one of these 3 materials at random</p><p><strong>Is Exterior </strong> - This boolean allows you to decide if the wall is an exterior wall (true) or an interior wall (false). This affects how doorways are generates, as portals on the exterior of the house are required by the Ontario building code to have a thick load-dispersing header, whereas portals inside the house generally do not require this</p><p><strong>Board Thickness</strong> - This is a float value that represents how thick, in meters, any generated board is</p><p><strong>Top Plate Thickness Multiplier</strong> - This is a float that allows you to change how thick the generated top plate is. This number is multiplied with the Board Thickness, meaning we can use it to double up the top plates when needed</p><p><strong>Stud Distance</strong> - This float defines how far apart, in meters, studs are generated along the length of the wall</p><p><strong>Header Thickness</strong> - This float defines how thick a generated header is</p><p><strong>Corner Locators</strong> - This is an array of Game Objects, specifically, it should contain 8 entries and the game objects should be the empty locator objects positioned on the corners of the volume</p><p><strong>Section Length, Remainder,</strong> <strong>Wait Time, </strong>and <strong>StudMarkers</strong> - These are defunct parameters that were used for monitoring how long the wall is; the remaining distance in the event a wall length was not evenly divisible by the Stud Distance; and how long the script should wait to allow for other scripts to do their thing; and the location of the markers that are used to place studs at the specified increments. These should be privatized.</p><p /><p>So lets break down how this all works.<br/><br/>The Start() function calls a coroutine. This coroutine makes the script wait briefly so that any WallPuncher Scripts in the scene can grab the references they need to function, though there is certainly a smarter and more fool-proof way to do this. </p><p>After waiting, the script then disables the box collider on the Wall Builder volume. Once the WindowPuncher scripts have their information, this collider is no longer needed.</p><p>The next two functions that are called do nearly the same thing - BottomPlate() creates the Bottom Plate of this section of wall, and TopPlate() creates the Top Plate of this section of wall. The bottom section will be as thick as is the Board Thickness is defined, and the bottom face of the Bottom Plate will overlap the bottom face of the Wall builder volume. Similarly, the Top Plate will be as thick as the Board Thickness, but is also multiplied by the Top Plate Thickness Multiplier. The top face of the Top plate will overlap with the top face of the wall Builder volume</p><div class="panel" style="background-color: #EAE6FF;border-color: #998DD9;border-width: 1px;"><div class="panelContent" style="background-color: #EAE6FF;">
<p>There is some repeated script here, as these functions are so similar. This could almost certainly be better handled by passing the needed info into the same function and using overrides. </p>
</div></div><p>The PlaceStudMarkers() function does a little bit more. First it gets the length of the volume by measuring from the zeroth corner locator to the fourth corner locator. After storing some other values, we then loop through trying to place stud markers at even intervals while still within the bounds of the Wall Builder volume.</p><p>If there is a remainder to trying to place the last marker, this means that there is no marker on the very end. We put one final marker on the line of markers</p><p>Next, for each stud marker we placed, we create a stud. We also track if the last stud is the last stud. </p><p>While studs are being placed they check to see if they're intersecting another stud. If they are, the older of the two is deleted.</p><div class="panel" style="background-color: #EAE6FF;border-color: #998DD9;border-width: 1px;"><div class="panelContent" style="background-color: #EAE6FF;">
<p>This may not be the cleanest of implementations and my result in some unintended deletion of boards. Of note, the Overlap Box function sometimes seems to be over ambition and may sometimes detect an overlap where there isn't one. Perhaps we can check if a collider is inside the stud we’re placing instead?</p>
</div></div><p>The stud also checks if it is overlapping a PortalBuilder volume. If it is, it replaced the stud it tried to make with a crippled stud if the portal is a door, or with two cripple studs if the portal is a window</p><h3 id="WallBuilderProcedural-WindowPuncher">Window Puncher</h3><p>The Window Puncher script’s job is to find the boolean overlapping space <em>(Figure 08)</em> between a Wall Builder volume and a Window Puncher volume. This space is then used as a reference point to build the parts that make up the rough opening.</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/775815232/799571999.png" data-image-src="attachments/775815232/799571999.png" data-height="554" data-width="634" data-unresolved-comment-count="0" data-linked-resource-id="799571999" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230911-182144.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="775815232" data-linked-resource-container-version="8" data-media-id="e1a607cf-f223-43bd-81fe-8bef898f0736" data-media-type="file"></span><p>The Window Puncher has the following parameters and behaviours:</p><p><strong>Is Window</strong> - This boolean allows us to determine if the portal is a window (true) or a door (false)</p><p><strong>Corner Locators</strong> - This is an array of 8 game objects used to track the corners of the volume, even if it is scaled, rotated, or scaled</p><p><strong>Collision Locators</strong> and <strong>Hit Wall Corner Locators</strong> - These are two arrays that keep track of where the collision occurs and the corners of the wall that is bisecting the Window Puncher. These should both be privatized</p><p><strong>Wait Time</strong> - This float sets a time, in seconds, that the system will wait for other scripts to do their thing</p><p><strong>Max Ray Distance </strong>- This float lets you set a distance, in meters, that the corners will check until</p><div class="panel" style="background-color: #EAE6FF;border-color: #998DD9;border-width: 1px;"><div class="panelContent" style="background-color: #EAE6FF;">
<p>It is likely more useful to have the raycast check from corner to corner instead of to a predetermined length. This way we will just have to adjust the size of the Window Puncher volume, which is visual, wheres the Max Ray Distance is invisible and somewhat abstract</p>
</div></div><p /><p>Lets do a quick breakdown of the Window Puncher:</p><p>We find this overlapping space by raycasting from the corners of the WindowPuncher volume, which has 8 empty game objects serving as locators much like the Wall Builder volume. The Wall Builder waits a little before it turns off its own collider to makes sure the Window Puncher can find it.</p><p>The points that raycasts find are stored, but only if all 8 points hit the same object. This means that if even one of the points misses a raycast, or if multiple different objects are hit, this process will abort itself. </p><p>This script then also stores the corners of the Wall Builder volume that it is bisecting, then the intersecting points are used to generate a new volume, the Portal Builder, and the Portal Builder inherits a bunch of information from the Window Puncher and the Wall Builder, which it will make use of</p><h3 id="WallBuilderProcedural-PortalBuilder">Portal Builder</h3><p>The portal builder script is responsible for building the parts that make up the rough openings. </p><p>The portal Builder has no parameters to configure on its own, as this is placed programatically, but it does inherit the following via the PassToPortal() function in the WindowPuncher script:</p><p><strong>cornerLocators</strong> - is an array of game objects passed to the PortalBuilder and are the same as the collisionLocators that are found by the raycasting done by the WindowPuncher. Essentially, these are the corner points of the inside of the rough opening</p><p><strong>wallCornerLocators</strong> - is an array of transforms passed to the Portal Builder and are the transforms of the corner locators from the Wall Builder volume that the Window Puncher bisects</p><p><strong>topPlateThicknessMultiplier, boardThickness, material1, material2,</strong> and<strong> material3</strong> - area ll the same values that were stored in the Wall Builder volume’s script and are used as reference when building the portal frame</p><p><strong>headerThickness</strong> - this value is the same as the headerthickness from the Wall Builder if the wall was an exterior wall, otherwise, this value is the same as boardThickness</p><p><strong>isWindow</strong> - is taken from the Window Puncher and affects how the portal is generated, either a door or a window</p><p><strong>myParent</strong> - is the Wall Builder volume that the Window puncher bisects</p><p /><p>The last breakdown (for now):</p><p>With all this inherited information, the very first thing that the Portal Builder does it build several arrays fo points. We create one for the header, the left and right jack stud, the left and right king stud, and the sill (if there is one). There's a lot of math going on here, because we use already generated points to create points relative to them. As an example, the header is generated first, and its cloud of points is generated relative to the top of the Portal Builder volume. We use the boardThickness to generate these points. The jack stud arrays then use the results of the header pint array to build it, and the king stud arrays use the jack stud array.</p><p>This then becomes a case of simply building the geometry as we have before.</p><div class="panel" style="background-color: #EAE6FF;border-color: #998DD9;border-width: 1px;"><div class="panelContent" style="background-color: #EAE6FF;">
<p>Once again, there is a lot of repeated code. This document is is desperate need of refactoring, and likely we can also just pass the arrays into the same function and make use of overloads to get rid of the redundancies. </p>
</div></div><h1 id="WallBuilderProcedural-KnownIssues">Known Issues</h1><p>Much like a Bethesda game, this incomplete and a buggy mess. While it is in a state that works, it only <em>technically</em> works, which is NOT the best kind of “works”</p><ol start="1"><li><p>Mentioned in some of the memos throughout, the codebase desperately needs to be refactored. Theres a lot of repeated code, and I’m sure things can be done smarter and more conventionally</p></li><li><p>Bottom plates do not account for doorways whatsoever. In the current state, the bottom plate is not cut to make way for a door. This may require what is tracked. Potentially we can create an array of intersecting areas, which may also solve issue 3:</p></li><li><p>Windows cannot be placed above other windows or above doors on the same wall section as the cripple studs will not be cut properly</p></li><li><p>Keeping all the studs as individual objects makes the scene file absolutely massive</p><ol start="1"><li><p>Removing the ProBuilder component seems to actually cut down roughly half of the bloat HOWEVER it also… removed the rendered image</p></li><li><p>ProBuilder lets us combine and export the objects, then we can reimport them as a single object. This means we loose the ability to address individual studs. This feature is not necessarily needed for this project, but may be useful in the future. We also lose the ability to have different materials on different boards, but we can still leverage the tri-planar shader to give some variety and break SOME of the monotony</p></li></ol></li><li><p>Doorways are currently generated solid… so the character controller cannot pass through them. Additionally, all the parts of the portal get parented to the Portal Builder volume, so deleting this part isn’t a simple one and done task. We could parent these parts to an empty though instead. </p></li><li><p>This script only currently works at runtime. It would be great to see it fully functional in editor without needing to play the game and copy and paste the resulting volumes</p></li><li><p>Scaling the walls to meet other walls is not an in-built feature to Unity. We could leverage ProBuilder, which would then let the developer snap to other objects more easily. However, ProBuilder shapes always have a scale of (1, 1, 1), and some of the scripts rely on the scale. We can, of course, restructure how this works and instead access the Read Only Object Size from a ProBuilder object</p></li></ol><h1 id="WallBuilderProcedural-RequestedFeatures/Wishlist">Requested Features/Wishlist</h1><ol start="1"><li><p>Allow this to work in editor and to update in real time, removing the need to use RunTime to generate the boards and copy them back into editor afterwards</p></li><li><p>Allow objects to snap scale to one another, increasing the ease of use and speed of use</p></li><li><p>Create an option menu of what is actually generated by the system: just solid walls with doors punched out? just studs? studs with sheathing? do we need insulation? etc</p></li><li><p>Create a version that can be used in VR where the player defines rooms by pointing at two locations, makes some selections, and outputs a whole room after simply selecting two corners of said room. This ideally also works as a flat-screen experience</p></li></ol>
                    </div>

                                        <div class="pageSection group">
                        <div class="pageSectionHeader">
                            <h2 id="attachments" class="pageSectionTitle">Attachments:</h2>
                        </div>

                        <div class="greybox" align="left">
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/775684149.png">image-20230802-154108.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/776241175.png">image-20230802-155622.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/775585813.png">image-20230802-163406.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/775716898.png">image-20230802-165317.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/775651368.png">image-20230802-170029.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/776044594.png">image-20230802-170126.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/775847978.png">image-20230802-171354.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/799932426.png">image-20230911-172712.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/799604763.png">image-20230911-172709.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/799637517.png">image-20230911-173151.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/775815232/799571999.png">image-20230911-182144.png</a> (image/png)
                                <br/>
                                                    </div>
                    </div>
                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on May 29, 2025 18:50</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
